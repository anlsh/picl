<!DOCTYPE html> <html lang="EN"> <head> <meta charset="utf-8"> <title>Picl</title> <style>html body{margin:0 auto 0 auto;padding:20px;max-width:1024px;font-family:sans-serif;font-size:14pt;overflow-y:scroll;}html body a{text-decoration:none;}html body a[href]{color:#0055AA;}html body a[href]:hover{color:#0088EE;}html body pre{background:#FAFAFA;border:1px solid #DDDDDD;padding:0.75em;overflow-x:auto;}html body pre >code a[href]{color:#223388;}article.project h1{font-size:1.7em;}article.project h1,article.project h2,article.project h3,article.project h4,article.project h5,article.project h6{margin:0.2em 0 0.1em 0;text-indent:1em;}article.project >header{text-align:center;}article.project >header img.logo{display:block;margin:auto;max-height:170px;}article.project >header h1{display:inline-block;text-indent:0;font-size:2.5em;}article.project >header .version{vertical-align:bottom;}article.project >header .languages{margin-top:-0.5em;text-transform:capitalize;}article.project >header .description{margin:0;}article.project >header .pages{margin-top:0.5em;font-size:1.2em;text-transform:capitalize;}article.project >header .pages a{display:inline-block;padding:0 0.2em;}article.project >section{margin:1em 0 1em 0;}article.project #index >ul{list-style:none;margin:0;padding:0;}article.project .row label{display:inline-block;min-width:8em;}article.project #system .row{display:flex;}article.project #system #dependencies{display:inline;margin:0;padding:0;}article.project #system #dependencies li{display:inline;padding:0 0.2em;}article.definition{margin:1em 0 0 0;}article.definition >header h1,article.definition >header h2,article.definition >header h3,article.definition >header h4,article.definition >header h5,article.definition >header h6{text-indent:0;display:inline-block;}article.definition >header ul{display:inline-block;list-style:none;margin:0;padding:0;}article.definition >header ul li{display:inline-block;padding:0 0.2em 0 0;}article.definition >header .visibility{display:none;}article.definition >header .visibility,article.definition >header .type{text-transform:lowercase;}article.definition >header .source-link{visibility:hidden;float:right;}article.definition >header .source-link:after{visibility:visible;content:"[SRC]";}article.definition .docstring{margin:0 0 0 1em;}article.definition .docstring pre{font-size:0.8em;white-space:pre-wrap;}.definition.package >header ul.nicknames{display:inline-block;list-style:none;margin:0;padding:0 0 0 1em;}.definition.package >header ul.nicknames li{display:inline;}.definition.package >header ul.nicknames:before{content:"(";}.definition.package >header ul.nicknames:after{content:")";}.definition.package ul.definitions{margin:0;list-style:none;padding:0 0 0 0.5em;}.definition.callable >header .name:before,.definition.type >header .name:before{content:"(";font-weight:normal;}.definition.callable >header .arguments:after,.definition.type >header .arguments:after{content:")";}.definition.callable >header .arguments .arguments:before,.definition.type >header .arguments .arguments:before{content:"(";}.definition.callable >header .arguments .argument,.definition.type >header .arguments .argument{padding:0;}.definition.callable >header .arguments .argument.lambda-list-keyword,.definition.type >header .arguments .argument.lambda-list-keyword{color:#991155;}.definition li>mark{background:none;border-left:0.3em solid #0088EE;padding-left:0.3em;display:block;} </style> </head> <body> <article class="project"> <header>  <h1>picl</h1>  <span class="version">0.0.1</span>  <nav class="languages">      </nav>  <p class="description">Python Itertools in Common Lisp</p>  <nav class="pages">    <a href="iterate/picl/index.html">picl/iterate</a>    <a href="tests/picl/index.html">picl/tests</a>  </nav> </header> <section id="documentation"><h1>Important Note: Pre-Release</h1> <p>I am currently soliciting feedback on PICL, so things aren't stable yet.
  This shouldn't last more than a few days though</p> <h1>picl</h1> <h4><em>Anish Moorthy <a href="mailto:anlsh@protonmail.com">mailto:anlsh@protonmail.com</a></em></h4> <p><em>Python Itertools in Common Lisp. Pronounced like &quot;pickle&quot;</em></p> <p>An (almost) complete port of Python's <a href="https://docs.python.org/3.8/library/itertools.html">itertools</a> package,
complete with laziness where applicable.
Pull requests welcome!</p> <h3>Objectives and Rationale</h3> <p>Other libraries, such as <a href="https://github.com/mabragor/cl-itertools">cl-itertools</a> and<a href="https://github.com/BnMcGn/snakes">snakes</a>, provide similar functionality</p> <p>Unfortunately <code>cl-itertools</code> remains very incomplete, and both<code>cl-itertools</code>and <code>snakes</code> and rely <code>cl-cont</code> meaning that they wont always play nice with certain
parts of CL (apparently)</p> <h3>Documentation</h3> <p>All functions are annotated with markdown docstrings. Thanks to <a href="https://github.com/Shinmera/staple">Staple</a> and <a href="https://github.com/htmlpreview/htmlpreview.github.com">htmlpreview</a>,
you can view the <a href="https://htmlpreview.github.io/?https://github.com/anlsh/picl/blob/master/docs/index.html">documentation here</a></p> <p>(Yes, I'm aware there's some sort of javascript garbage at the bottom of the
  page: it seems like a bug with htmlpreview:. It doesn't truncate the
  documentation however, so I suppose this is just the price I pay for not
  knowing how to host webpages myself)</p> <p>You can build the documentation yourself like so</p> <pre><code>(<a href="https://Shinmera.github.io/staple/#GENERIC-FUNCTION%20STAPLE%3AGENERATE" class="xref">staple:generate</a> :picl :if-exists :supersede)</code></pre> <p>If you don't have the <code>iterate</code> package loaded it'll complain about invalid
function names, but you can ignore that.</p> <h3>Testing</h3> <p>A fairly comprehensive test suite is provided using <a href="https://common-lisp.net/project/fiveam/">FiveAM</a>.</p> <p>You can run the test suite yourself like so</p> <pre><code><span class="code"><span class="paren1">(<span class="code">ql:quickload <span class="keyword">:picl/tests</span></span>)</span>
<span class="paren1">(<span class="code">fiveam:run! 'picl/tests:suite</span>)</span></span></code></pre> <h3>Concepts and How-To</h3> <p>An &quot;iterator&quot; in PICL is simply a function taking no arguments and producing two
values: the payload and the alive-indicator. The payload represent's the
iterator's next item, and the alive-indicator should be truthy until after the
iterator is consumed.</p> <p>By example</p> <pre><code>(let ((it (<a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a> '(1 2))))
  (<a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a> it)  ;; (values 1 t)
  (<a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a> it)  ;; (values 2 t)
  (<a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a> it)) ;; (values nil nil)</code></pre> <p>After returning <code>nil</code>, all further <code><a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a></code> calls should also produce <code>nil</code> as
quickly as possible. Furthermore when the alive indicator is <code>nil</code>, the payload
should be ignored.</p> <p>To create iterators over your own objects, specialize the <code><a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a></code> generic function appropriately to produce a function satisfying the conditions
described above. For instance, the <code><a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a></code> definition for lists is</p> <pre><code>(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> <a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a> ((obj <a href="http://l1sp.org/cl/list" class="xref">list</a>))
  (lambda ()
    (if obj
        (<a href="http://l1sp.org/cl/values" class="xref">values</a> (<a href="http://l1sp.org/cl/prog1" class="xref">prog1</a> (<a href="http://l1sp.org/cl/car" class="xref">car</a> obj) (setf obj (<a href="http://l1sp.org/cl/cdr" class="xref">cdr</a> obj))) t)
        (<a href="http://l1sp.org/cl/values" class="xref">values</a> nil nil))))</code></pre> <p>Specializations for lists and vectors are predefined. A universal <code>in-it</code> driver is also provided for <a href="https://common-lisp.net/project/iterate/">Iterate</a> through the <code>picl/iterate</code> system.</p> <pre><code><span class="code"><span class="paren1">(<span class="code">ql:quickload '<span class="paren2">(<span class="code"><span class="keyword">:picl</span> <span class="keyword">:picl/iterate</span></span>)</span></span>)</span>

<span class="paren1">(<span class="code">iterate:iter
    <span class="paren2">(<span class="code">iterate:for i in-it #<span class="paren3">(<span class="code">1 2 3</span>)</span></span>)</span>
    <span class="paren2">(<span class="code">iterate:collect i</span>)</span></span>)</span>
<span class="comment">;; (1 2 3)
</span>
<span class="paren1">(<span class="code">iterate:iter
    <span class="paren2">(<span class="code">iterate:for i in-it <span class="paren3">(<span class="code">picl:permutations '<span class="paren4">(<span class="code">1 2 3</span>)</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="code">iterate:collect i</span>)</span></span>)</span>
<span class="comment">;; (#(1 2 3) #(1 3 2) #(2 1 3) #(2 3 1) #(3 1 2) #(3 2 1))</span></span></code></pre> <p>though you should probably <code>:use</code> iterate so as not to have the <code>iterate:</code> prefix everywhere</p> <h4>Missing Functionality</h4> <p>The only functions which are still missing are <a href="https://docs.python.org/3.8/library/itertools.html#itertools.groupby">groupby</a> and <a href="https://docs.python.org/3.8/library/itertools.html#itertools.accumulate">accumulate</a>.</p> <h3>A note on <code>:use</code></h3> <p>This is a new library, and so I have the liberty to tell you this: do not, and I
mean <em>do not</em> <code>:use</code> this package. This library might export new symbols in the
future, and I do not care about accomodating the use of <code>:use</code>.</p> <p>Use <a href="(https://gist.github.com/phoe/2b63f33a2a4727a437403eceb7a6b4a3)">package local
nicknames</a> instead. It would also be cool if you could include similar disclaimers in any
new CL packages you release and stop <code>:use</code>ing things going forward.</p> <h3>Future Work</h3> <ul> <li>Port the more-itertools recipes found at bottom of the Python itertools
package</li> <li>Port the <a href="https://pypi.org/project/more-itertools/">more-iterools</a> package
(this seems like a big job)</li> </ul> <h3>Acknowledgements</h3> <p>Python, its itertools package, and all those who have contributed to it.</p> <p>Shinmera, for creating <a href="https://github.com/shinmera/staple">Staple</a></p> <h2>License</h2> <p>This project is provided under the MIT License (see LICENSE.md)</p> </section>   <section id="system"> <h2>System Information</h2>  <div class="row"> <label for="version">Version:</label> <a id="version">0.0.1</a> </div>   <div class="row"> <label for="dependencies">Dependencies:</label> <ul id="dependencies"><li><a class="external" href="https://github.com/EuAndreh/defclass-std">defclass-std</a></li><li><a class="external">alexandria</a></li></ul> </div>   <div class="row"> <label for="author">Author:</label> <a id="author" href="mailto:anlsh@protonmail.com">Anish Moorthy</a> </div>   <div class="row"> <label for="license">License:</label> <a id="license" href="https://github.com/anlsh/picl/blob/master/LICENSE.md">MIT</a> </div>   <div class="row"> <label for="homepage">Homepage:</label> <a id="homepage" href="https://anlsh.github.io/picl/">https://anlsh.github.io/picl/</a> </div>  </section>    <section id="index"> <h2>Definition Index</h2> <ul> <li> <article class="definition package" id="PACKAGE PICL"> <header> <h3> <a href="#PACKAGE%20PICL">PICL</a> </h3> <ul class="nicknames"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> <ul class="definitions"> <li> <article class="definition function callable" id="FUNCTION PICL:CHAIN"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACHAIN">CHAIN</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERABLES</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L133">Source</a>  </header> <div class="docstring"><p>Yields the elements of the first iterable in <code>iterable</code>, then the second, etc.</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACHAIN" class="xref">chain</a> '(1 2 3) '(4 5 6) (<a href="http://l1sp.org/cl/count" class="xref">count</a> 7))
;; 1, 2, 3, 4, 5, 6, 7 etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:COMBINATIONS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACOMBINATIONS">COMBINATIONS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">R</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/combinatoric.lisp#L143">Source</a>  </header> <div class="docstring"><p>r-combinations of input iterable, returned as vectors in lexicographic order.</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACOMBINATIONS" class="xref">combinations</a> 2 '(1 2 3))
;; #(1 2), #(1 3), #(2 3)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:COMBINATIONS-WITH-REP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACOMBINATIONS-WITH-REP">COMBINATIONS-WITH-REP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">R</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/combinatoric.lisp#L173">Source</a>  </header> <div class="docstring"><p>r-combinations with replacement of input iterable, returned as vectors in lexicographic
order</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACOMBINATIONS" class="xref">combinations</a> 2 '(1 2 3))
;; #(1 1), #(1 2), #(1 3), #(2 1), #(2 2), #(2 3), #(3 1), #(3 2), #(3 3)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:COMPRESS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACOMPRESS">COMPRESS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">BASE-ITERABLE</li>    <li class="argument">BOOL-ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L218">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>base-iterable</code> while the corresponding element in <code>bool-iterable</code> is truthy.</p> <p>Stops when either of its arguments is consumed</p> <pre><code>(iterator-compress (<a href="http://l1sp.org/cl/count" class="xref">count</a>) (t nil t nil t nil))
;; 0 2 4</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:CYCLE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACYCLE">CYCLE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L83">Source</a>  </header> <div class="docstring"><p>Continually yields the elements of its argument in order, starting over when the end is
reached</p> <p>If the base iterator is empty, the result of iterator-cycle will be too</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACYCLE" class="xref">cycle</a> '(1 2 3 4))
;; 1, 2, 3, 4, 1, 2, 3, 4, etc
(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3ACYCLE" class="xref">cycle</a> '()))
;; nil</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:DROPWHILE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ADROPWHILE">DROPWHILE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L242">Source</a>  </header> <div class="docstring"><p>Drops all elements of <code>base-iter</code> until <code>pred</code> first returns false, then yields all further
elements</p> <pre><code>(<a href="#FUNCTION%20PICL%3ADROPWHILE" class="xref">dropwhile</a> (lambda (x) (<a href="http://l1sp.org/cl/%3C" class="xref">&lt;</a> 3 x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 3, 4, 5, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:EMPTY-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AEMPTY-ITERATOR">EMPTY-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/utils.lisp#L32">Source</a>  </header> <div class="docstring"><p>Returns an empty iterator</p> <pre><code>(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3AEMPTY-ITERATOR" class="xref">empty-iterator</a>))
;; nil</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ENUMERATE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AENUMERATE">ENUMERATE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERABLE</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">CURR</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L40">Source</a>  </header> <div class="docstring"><p>Yield two-element lists of indices (beginning at curr) and their corresponding elements in <code>iterable</code></p> <pre><code>(<a href="#FUNCTION%20PICL%3AENUMERATE" class="xref">enumerate</a> '(a b c d))
;; (0 a), (1 b), (2 c), (3 d)
(<a href="#FUNCTION%20PICL%3AENUMERATE" class="xref">enumerate</a> '(a b c d) 3)
;; (3 a), (4 b), (5 c), (6 d)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:FILTER"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AFILTER">FILTER</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L265">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>iterable</code> for which <code>predicate</code> returns true</p> <pre><code>(<a href="#FUNCTION%20PICL%3AFILTER" class="xref">filter</a> (lambda (x) (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 0, 2, 4, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:FILTERFALSE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AFILTERFALSE">FILTERFALSE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L283">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>iterable</code> for which <code>predicate</code> returns false</p> <pre><code>(<a href="#FUNCTION%20PICL%3AFILTERFALSE" class="xref">filterfalse</a> (lambda (x) (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 1, 3, 5, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ICOUNT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AICOUNT">ICOUNT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">START</li>    <li class="argument">STEP</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L4">Source</a>  </header> <div class="docstring"><p>Yields the elements `start, start + 1<em>step, start + 2</em>step, etc</p> <pre><code>(<a href="http://l1sp.org/cl/count" class="xref">count</a> 2 4)
;; 2, 6, 10, 14, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:IMAP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AIMAP">IMAP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERABLES</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L310">Source</a>  </header> <div class="docstring"><p>Applies <code>fn</code> to the first elements of each iterable in <code>iterables</code>, then to the seconds, etc</p> <pre><code>(<a href="#FUNCTION%20PICL%3AIMAP" class="xref">imap</a> <a href="http://l1sp.org/cl/%2B" class="xref">#'+</a> '(1 2) '(3 4))
;; 4, 6</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ISLICE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AISLICE">ISLICE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERABLE</li>    <li class="argument">START</li>    <li class="argument">STOP</li>    <li class="argument">DELTA</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L339">Source</a>  </header> <div class="docstring"><p>Works like Python's <a href="https://docs.python.org/3.8/library/itertools.html#itertools.islice">islice</a></p> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ITER-TO-LIST"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AITER-TO-LIST">ITER-TO-LIST</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/utils.lisp#L4">Source</a>  </header> <div class="docstring"><p>Reads <code>iterable</code> into a list</p> <pre><code>(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 4))
;; (0 1 2 3)
(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="http://l1sp.org/cl/count" class="xref">count</a>))
;; Out of memory error!</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ITER-TO-VEC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AITER-TO-VEC">ITER-TO-VEC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/utils.lisp#L20">Source</a>  </header> <div class="docstring"><p>Reads <code>iterable</code> into a vector</p> <pre><code>(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 4))
;; #(0 1 2 3)
(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="http://l1sp.org/cl/count" class="xref">count</a>))
;; Out of memory error!</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:NEXT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ANEXT">NEXT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/interface.lisp#L11">Source</a>  </header> <div class="docstring"><p>Produces two values, the payload and the alive-indicator</p> <p>While iterator is not yet exhausted, calling next will yield its next item and a
  truthy alive-indicator</p> <p>After iterator has been exhausted all further calls should yield an alive-indicator
  of nil, and the payload should be ignored by the callee</p> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:NFOLD-PRODUCT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ANFOLD-PRODUCT">NFOLD-PRODUCT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">N</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/combinatoric.lisp#L53">Source</a>  </header> <div class="docstring"><p>Computes the n-fold Cartesian product of an iterable with itself.</p> <p>Essentially equivalent to <code>(apply #'product (iter-to-list (tee n iterable))</code>, but with
much better memory usage</p> <pre><code>(<a href="#FUNCTION%20PICL%3ANFOLD-PRODUCT" class="xref">nfold-product</a> 3 '(1 2))
;; #(1 1 1), #(1 1 2), #(1 2 1), #(1 2 2), #(2 1 1), #(2 1 2), #(2 2 1), #(2 2 2)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:PERMUTATIONS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3APERMUTATIONS">PERMUTATIONS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">S0</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">S1</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/combinatoric.lisp#L91">Source</a>  </header> <div class="docstring"><p><code>r</code>-permutations of input iterable, returned as vectors in lexicographic order.</p> <p>When a single argument is given, it should be an iterable and <code>r</code> will default to its length.</p> <p>When two arguments are given, the first corresponds to <code>r</code> and the second to the iterable</p> <pre><code>(<a href="#FUNCTION%20PICL%3APERMUTATIONS" class="xref">permutations</a> '(1 2 3))
;; #(1 2 3), #(1 3 2), #(2 1 3), #(2 3 1), #(3 1 2), #(3 2 1)
(<a href="#FUNCTION%20PICL%3APERMUTATIONS" class="xref">permutations</a> 2 '(1 2 3))
;; #(1 2), #(1 3), #(2 1), #(2 3), #(3 1), #(3 2)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:PRODUCT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3APRODUCT">PRODUCT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERABLES</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/combinatoric.lisp#L7">Source</a>  </header> <div class="docstring"><p>Cartesian product of input iterables, returned as vectors in lexicographic order.</p> <p>Due to the awkwardness in mixing <code>&amp;rest</code> and <code>&amp;key</code> parameters in lambda lists, this function
does not implement the <code><a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a></code> argument supported in <a href="https://docs.python.org/3/library/itertools.html#itertools.product">Python's version</a>.
Use <code><a href="#FUNCTION%20PICL%3ANFOLD-PRODUCT" class="xref">picl:nfold-product</a></code> instead.</p> <pre><code>(<a href="#FUNCTION%20PICL%3APRODUCT" class="xref">product</a> '(1 2) '(3 4))
;; #(1 3), #(1 4), #(2 3), #(2 4)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:RANGE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ARANGE">RANGE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">S0</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">S1</li>    <li class="argument">STEP</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L17">Source</a>  </header> <div class="docstring"><p>Works <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-range">as in Python</a> but produces an iterator (as defined by PICL) instead of a Python-esque range object</p> <pre><code>(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 5)
;; 0, 1, 2, 3, 4
(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 2 5)
;; 2, 3, 4
(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> -2)
;; 0, -1
(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 1 7 2)
;; 1, 3, 5</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:REPEAT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AREPEAT">REPEAT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">S0</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">S1</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L59">Source</a>  </header> <div class="docstring"><p>If a single argument is given, yields <code>s0</code> repeatedly forever</p> <p>If two arguments are given, then yields <code>s1</code> <code>s0</code> times</p> <pre><code>(<a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a> t)
;; t, t, etc
(<a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a> 4 t)
;; t, t, t, t</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:STARMAP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ASTARMAP">STARMAP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FN</li>    <li class="argument">ITERABLE-OF-ITERABLES</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L294">Source</a>  </header> <div class="docstring"><p>Applies <code>fn</code> to the first argument of <code>iterable-of-iterables</code>, then the second, etc</p> <pre><code>(<a href="#FUNCTION%20PICL%3ASTARMAP" class="xref">starmap</a> <a href="http://l1sp.org/cl/%2B" class="xref">#'+</a> '(1 2) '(3 4))
;; 3, 7</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:TAKE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ATAKE">TAKE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">N</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/utils.lisp#L41">Source</a>  </header> <div class="docstring"><p>Returns a list consisting of the first <code>n</code> (or fewer, if the iterator runs out) items of iterable</p> <pre><code>(<a href="#FUNCTION%20PICL%3ATAKE" class="xref">take</a> 5 (<a href="http://l1sp.org/cl/count" class="xref">count</a>))
;; (0 1 2 3 4)
take 30 (<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 4)
;; (0 1 2 3)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:TAKEWHILE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ATAKEWHILE">TAKEWHILE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L319">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>iterable</code> for which <code>predicate</code> is truthy, terminating once it
first returns nil</p> <pre><code>(<a href="#FUNCTION%20PICL%3ATAKEWHILE" class="xref">takewhile</a> (lambda (x) (<a href="http://l1sp.org/cl/%3C" class="xref">&lt;</a> 3 x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 0, 1, 2</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:TEE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ATEE">TEE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">N</li>    <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L384">Source</a>  </header> <div class="docstring"><p>Returns a vector of <code>n</code> independent copies of <code>iterable</code>. <code>iterable</code> itself should not be used
after it has been passed to <code><a href="#FUNCTION%20PICL%3ATEE" class="xref">tee</a></code>, otherwise the tees will not be properly updated</p> <p>If the base iterable is large be careful not to advance any copy too far ahead of the others,
so as to avoid memory issues</p> <pre><code>tees = (<a href="#FUNCTION%20PICL%3ATEE" class="xref">tee</a> 2 '(1 2 3 4))
;; tees[0] =&gt; 1, 2, 3, 4
;; tees[1] =&gt; 1, 2, 3, 4</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ZIP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AZIP">ZIP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERABLES</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L167">Source</a>  </header> <div class="docstring"><p>Returns vectors consisting of the first elements from each iterable in <code>iterable</code>, then the
second, etc until one is consumed</p> <pre><code>(<a href="#FUNCTION%20PICL%3AZIP" class="xref">zip</a> '(1 2 3) '(a b c d))
;; #(1 a). #(2 b), #(3 c)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ZIP-LONGEST"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AZIP-LONGEST">ZIP-LONGEST</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FILL-ITEM</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERABLES</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/itertools.lisp#L206">Source</a>  </header> <div class="docstring"><p>Returns vectors consisting of the first elements from each iterable in <code>iterable</code>, then the
second, etc until <em>all</em> are consumed. Once a constituent iterable has been exhausted, <code>fill-value</code> is used to pad the vector in its place.</p> <pre><code>(<a href="#FUNCTION%20PICL%3AZIP" class="xref">zip</a> nil '(1 2 3) '(a b c d))
;; #(1 a). #(2 b), #(3 c), #(nil d)</code></pre> </div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION PICL:MAKE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR">MAKE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERABLE</li>  </ul>  <a class="source-link" href="https://github.com/anlsh/picl/blob/master/src/interface.lisp#L3">Source</a>  </header> <div class="docstring"><p>Creates an iterator from <code>iterable</code>: an iterator is simply anything which can be passed
   as an argument to <code><a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a></code></p> </div> </article> </li> </ul> </article> </li> </ul> </section>  </article> <script>window.addEventListener("DOMContentLoaded", function(){
    var unmarkElement = function(el){
        if(el.tagName === "mark" || el.tagName === "MARK"){
            [].forEach.call(el.childNodes, function(child){
                el.parentNode.insertBefore(child, el);
            });
            el.parentNode.removeChild(el);
        }else if(el.parentNode.tagName === "mark"){
            return unmarkElement(el.parentNode);
        }
        return null;
    }

    var unmarkAll = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("mark"), unmarkElement);
    }
    
    var markElement = function(el){
        if(el.parentNode.tagName === "mark" || el.parentNode.tagName === "MARK"){
            return el.parentNode;
        } else {
            unmarkAll();
            var marked = document.createElement("mark");
            el.parentNode.insertBefore(marked, el);
            marked.appendChild(el);
            return marked;
        }
    }

    var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html> 