<!DOCTYPE html> <html lang="EN"> <head> <meta charset="utf-8"> <title>Picl</title> <style>html body {
  margin: 0 auto 0 auto;
  padding: 20px;
  max-width: 1024px;
  font-family: sans-serif;
  font-size: 14pt;
  overflow-y: scroll;
}

html body a {
  text-decoration: none;
}

html body a[href] {
  color: #0055AA;
}

html body a[href]:hover {
  color: #0088EE;
}

html body pre {
  background: #FAFAFA;
  border: 1px solid #DDDDDD;
  padding: 0.75em;
  overflow-x: auto;
}

html body pre >code a[href] {
  color: #223388;
}

article.project h1 {
  font-size: 1.7em;
}

article.project h1,article.project h2,article.project h3,article.project h4,article.project h5,article.project h6 {
  margin: 0.2em 0 0.1em 0;
  text-indent: 1em;
}

article.project >header {
  text-align: center;
}

article.project >header img.logo {
  display: block;
  margin: auto;
  max-height: 170px;
}

article.project >header h1 {
  display: inline-block;
  text-indent: 0;
  font-size: 2.5em;
}

article.project >header .version {
  vertical-align: bottom;
}

article.project >header .languages {
  margin-top: -0.5em;
  text-transform: capitalize;
}

article.project >header .description {
  margin: 0;
}

article.project >header .pages {
  margin-top: 0.5em;
  font-size: 1.2em;
  text-transform: capitalize;
}

article.project >header .pages a {
  display: inline-block;
  padding: 0 0.2em;
}

article.project >section {
  margin: 1em 0 1em 0;
}

article.project #index >ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

article.project .row label {
  display: inline-block;
  min-width: 8em;
}

article.project #system .row {
  display: flex;
}

article.project #system #dependencies {
  display: inline;
  margin: 0;
  padding: 0;
}

article.project #system #dependencies li {
  display: inline;
  padding: 0 0.2em;
}

article.definition {
  margin: 1em 0 0 0;
}

article.definition >header h1,article.definition >header h2,article.definition >header h3,article.definition >header h4,article.definition >header h5,article.definition >header h6 {
  text-indent: 0;
  display: inline-block;
}

article.definition >header ul {
  display: inline-block;
  list-style: none;
  margin: 0;
  padding: 0;
}

article.definition >header ul li {
  display: inline-block;
  padding: 0 0.2em 0 0;
}

article.definition >header .visibility {
  display: none;
}

article.definition >header .visibility,article.definition >header .type {
  text-transform: lowercase;
}

article.definition >header .source-link {
  visibility: hidden;
  float: right;
}

article.definition >header .source-link:after {
  visibility: visible;
  content: "[SRC]";
}

article.definition .docstring {
  margin: 0 0 0 1em;
}

article.definition .docstring pre {
  font-size: 0.8em;
  white-space: pre-wrap;
}

.definition.package >header ul.nicknames {
  display: inline-block;
  list-style: none;
  margin: 0;
  padding: 0 0 0 1em;
}

.definition.package >header ul.nicknames li {
  display: inline;
}

.definition.package >header ul.nicknames:before {
  content: "(";
}

.definition.package >header ul.nicknames:after {
  content: ")";
}

.definition.package ul.definitions {
  margin: 0;
  list-style: none;
  padding: 0 0 0 0.5em;
}

.definition.callable >header .name:before,.definition.type >header .name:before {
  content: "(";
  font-weight: normal;
}

.definition.callable >header .arguments:after,.definition.type >header .arguments:after {
  content: ")";
}

.definition.callable >header .arguments .arguments:before,.definition.type >header .arguments .arguments:before {
  content: "(";
}

.definition.callable >header .arguments .argument,.definition.type >header .arguments .argument {
  padding: 0;
}

.definition.callable >header .arguments .argument.lambda-list-keyword,.definition.type >header .arguments .argument.lambda-list-keyword {
  color: #991155;
}

.definition li>mark {
  background: none;
  border-left: 0.3em solid #0088EE;
  padding-left: 0.3em;
  display: block;
} </style> </head> <body> <article class="project"> <header>  <h1>picl</h1>  <span class="version">0.0.1</span>  <nav class="languages">      </nav>  <p class="description">Python Itertools in Common Lisp</p>  <nav class="pages">    <a href="iterate/picl/index.html">picl/iterate</a>    <a href="tests/picl/index.html">picl/tests</a>  </nav> </header> <section id="documentation"><h1>picl</h1> <h4><em>Anish Moorthy <a href="mailto:anlsh@protonmail.com">mailto:anlsh@protonmail.com</a></em></h4> <p><em>Python Iterators in Common Lisp. Pronounced like &quot;pickle&quot;</em></p> <p>An (almost) complete port of Python's <a href="https://docs.python.org/3.8/library/itertools.html">itertools</a> package.
Pull requests welcome!</p> <h3>Objectives and Rationale</h3> <p>I am aware of other libraries providing similar functionality, notably
- <a href="https://github.com/mabragor/cl-itertools">cl-itertools</a> - <a href="https://github.com/BnMcGn/snakes">snakes</a>, in addition to providing
  Python-style generators</p> <p>Unfortunately <code>cl-itertools</code> remains very incomplete,
and <code>snakes</code> relies on <code>cl-cont</code> meaning that it doesn't play nice
with the condition system (apparently).</p> <p>My hope is to reduce fragmentation of the Common Lisp ecosystem by providing a
library which is complete, performant, and &quot;seamless&quot; (whatever that means
nowadays).</p> <h3>Documentation &amp; Testing</h3> <p>All functions are annotated with markdown docstrings. Thanks to Shinmera's <a href="https://github.com/Shinmera/staple">Staple</a></p> <h3>Concepts and How-To</h3> <p>An &quot;iterator&quot; in PICL is simply a function taking no arguments and producing two
values: the payload and the alive-indicator. The payload represent's the
iterator's next item, and the alive-indicator should be truthy until after the
iterator is consumed.</p> <p>By example</p> <pre><code>(<a href="http://l1sp.org/cl/defvar" class="xref">defvar</a> it (<a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a> '(1 2 3)))
(<a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a> it) ;; 1 t
(<a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a> it) ;; 2 t
(<a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a> it) ;; nil nil</code></pre> <p>After returning <code>nil</code>, all further <code><a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a></code> calls should also produce <code>nil</code> as
quickly as possible. Furthermore when the alive indicator is <code>nil</code>, the payload
should be ignored.</p> <p>To create iterators over your own objects, specialize the <code><a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a></code> generic function appropriately to produce a function satisfying the conditions
described above. For instance, the <code><a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a></code> definition for lists is</p> <pre><code>(<a href="http://l1sp.org/cl/defmethod" class="xref">defmethod</a> <a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR" class="xref">make-iterator</a> ((obj <a href="http://l1sp.org/cl/list" class="xref">list</a>))
  (lambda ()
    (if obj
        (<a href="http://l1sp.org/cl/values" class="xref">values</a> (<a href="http://l1sp.org/cl/prog1" class="xref">prog1</a> (<a href="http://l1sp.org/cl/car" class="xref">car</a> obj) (setf obj (<a href="http://l1sp.org/cl/cdr" class="xref">cdr</a> obj))) t)
        (<a href="http://l1sp.org/cl/values" class="xref">values</a> nil nil))))</code></pre> <p>Specializations for <code><a href="#FUNCTION%20PICL%3ALIST" class="xref">list</a></code> and <code><a href="#FUNCTION%20PICL%3AVECTOR" class="xref">vector</a></code> are defined in PICL. A universal <code>in-it</code> driver is also provided for <a href="https://common-lisp.net/project/iterate/">Iterate</a> through the <code>picl/iterate</code> system.</p> <pre><code>(ql:quickload '(:picl :picl/iterate))

(iterate:iter
    (iterate:for i in-it #(1 2 3))
    (iterate:collect i))
;; (1 2 3)
(iterate:iter
    (iterate:for i in-it (picl:permutations '(1 2 3)))
    (iterate:collect i))
;;(#(1 2 3) #(1 3 2) #(2 1 3) #(2 3 1) #(3 1 2) #(3 2 1))</code></pre> <p>though you should probably <code>:use</code> iterate so as not to have the <code>iterate:</code> prefix
everywhere</p> <h4>Missing Functionality</h4> <p>The only functions which are still missing are <a href="https://docs.python.org/3.8/library/itertools.html#itertools.groupby">groupby</a> and <a href="https://docs.python.org/3.8/library/itertools.html#itertools.accumulate">accumulate</a>.</p> <p>PICL's product function is missing the <code><a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a></code> keyword argument from <a href="https://docs.python.org/3.8/library/itertools.html#itertools.product">Python's version </a>.
The same effect can be achieved with <code>(product (tee iterable n-repeats))</code>,
though at a higher memory cost</p> <h3>A note on <code>:use</code></h3> <p>This is a new library, and so I have the liberty to tell you this: do not, and I
mean <em>do not</em> <code>:use</code> this package. This library might export new symbols in the
future, and I do not care about accomodating the use of <code>:use</code>.</p> <p>Use a <a href="(https://gist.github.com/phoe/2b63f33a2a4727a437403eceb7a6b4a3)">package local
nicknames</a> instead. It would also be cool if you could include similar disclaimers in any
new CL packages you release and stop <code>:use</code>ing things going forward.</p> <h3>Future Work</h3> <ul> <li>Implement Python's default functions for working with iterables (map, zip, etc)</li> <li>Port the more-itertools recipes found at bottom of the Python itertools
package</li> <li>Port the <a href="https://pypi.org/project/more-itertools/">more-iterools</a> package
(this might be a big job)</li> </ul> <h3>Acknowledgements</h3> <p>Python, its itertools package, and all those who have contributed to it.</p> <p>Shinmera, for creating <a href="https://github.com/shinmera/staple">Staple</a></p> <h2>License</h2> <p>This project is provided under the MIT License (see LICENSE.md)</p> </section>   <section id="system"> <h2>System Information</h2>  <div class="row"> <label for="version">Version:</label> <a id="version">0.0.1</a> </div>   <div class="row"> <label for="dependencies">Dependencies:</label> <ul id="dependencies"><li><a class="external" href="https://github.com/EuAndreh/defclass-std">defclass-std</a></li><li><a class="external">alexandria</a></li></ul> </div>   <div class="row"> <label for="author">Author:</label> <a id="author" href="mailto:anlsh@protonmail.com">Anish Moorthy</a> </div>   <div class="row"> <label for="license">License:</label> <a id="license" href="file:///home/anlsh/Code/picl/LICENSE.md">MIT</a> </div>    </section>    <section id="index"> <h2>Definition Index</h2> <ul> <li> <article class="definition package" id="PACKAGE PICL"> <header> <h3> <a href="#PACKAGE%20PICL">PICL</a> </h3> <ul class="nicknames"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> <ul class="definitions"> <li> <article class="definition function callable" id="FUNCTION PICL:CHAIN"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACHAIN">CHAIN</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERLIKES</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#127:0">Source</a>  </header> <div class="docstring"><p>Yields the elements of the first iterable in <code>iterlike</code>, then the second, etc.</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACHAIN" class="xref">chain</a> '(1 2 3) '(4 5 6) (<a href="http://l1sp.org/cl/count" class="xref">count</a> 7))
;; 1, 2, 3, 4, 5, 6, 7 etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:COMBINATIONS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACOMBINATIONS">COMBINATIONS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>    <li class="argument">R</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/combinatoric.lisp#100:0">Source</a>  </header> <div class="docstring"><p>r-combinations of input iterable, returned as vectors in lexicographic order.</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACOMBINATIONS" class="xref">combinations</a> '(1 2 3) 2)
;; #(1 2), #(1 3), #(2 3)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:COMBINATIONS-WITH-REP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACOMBINATIONS-WITH-REP">COMBINATIONS-WITH-REP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>    <li class="argument">R</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/combinatoric.lisp#131:0">Source</a>  </header> <div class="docstring"><p>r-combinations with replacement of input iterable, returned as vectors in lexicographic
order</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACOMBINATIONS" class="xref">combinations</a> '(1 2 3) 2)
;; #(1 1), #(1 2), #(1 3), #(2 1), #(2 2), #(2 3), #(3 1), #(3 2), #(3 3)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:COMPRESS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACOMPRESS">COMPRESS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">BASE-ITERLIKE</li>    <li class="argument">BOOL-ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#212:0">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>base-iterlike</code> while the corresponding element in <code>bool-iterlike</code> is truthy.</p> <p>Stops when either of its arguments is consumed</p> <pre><code>(iterator-compress (<a href="http://l1sp.org/cl/count" class="xref">count</a>) (t nil t nil t nil))
;; 0 2 4</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:CYCLE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ACYCLE">CYCLE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#77:0">Source</a>  </header> <div class="docstring"><p>Continually yields the elements of its argument in order, starting over when the end is
reached</p> <p>If the base iterator is empty, the result of iterator-cycle will be too</p> <pre><code>(<a href="#FUNCTION%20PICL%3ACYCLE" class="xref">cycle</a> '(1 2 3 4))
;; 1, 2, 3, 4, 1, 2, 3, 4, etc
(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3ACYCLE" class="xref">cycle</a> '()))
;; nil</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:DROPWHILE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ADROPWHILE">DROPWHILE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#236:0">Source</a>  </header> <div class="docstring"><p>Drops all elements of <code>base-iter</code> until <code>pred</code> first returns false, then yields all further
elements</p> <pre><code>(<a href="#FUNCTION%20PICL%3ADROPWHILE" class="xref">dropwhile</a> (lambda (x) (<a href="http://l1sp.org/cl/%3C" class="xref">&lt;</a> 3 x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 3, 4, 5, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:EMPTY-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AEMPTY-ITERATOR">EMPTY-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/utils.lisp#32:0">Source</a>  </header> <div class="docstring"><p>Returns an empty iterator</p> <pre><code>(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3AEMPTY-ITERATOR" class="xref">empty-iterator</a>))
;; nil</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ENUMERATE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AENUMERATE">ENUMERATE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">CURR</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#37:0">Source</a>  </header> <div class="docstring"><p>Yield two-element lists of indices (beginning at curr) and their corresponding elements in <code>iterlike</code></p> <pre><code>(<a href="#FUNCTION%20PICL%3AENUMERATE" class="xref">enumerate</a> '(a b c d))
;; #(0 a), #(1 b), #(2 c), #(3 d)
(<a href="#FUNCTION%20PICL%3AENUMERATE" class="xref">enumerate</a> '(a b c d) 3)
;; #(3 a), #(4 b), #(5 c), #(6 d)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:FILTER"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AFILTER">FILTER</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#259:0">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>iterlike</code> for which <code>predicate</code> returns true</p> <pre><code>(<a href="#FUNCTION%20PICL%3AFILTER" class="xref">filter</a> (lambda (x) (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 0, 2, 4, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:FILTERFALSE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AFILTERFALSE">FILTERFALSE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#277:0">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>iterlike</code> for which <code>predicate</code> returns false</p> <pre><code>(<a href="#FUNCTION%20PICL%3AFILTERFALSE" class="xref">filterfalse</a> (lambda (x) (<a href="http://l1sp.org/cl/evenp" class="xref">evenp</a> x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 1, 3, 5, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ICOUNT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AICOUNT">ICOUNT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">START</li>    <li class="argument">STEP</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#4:0">Source</a>  </header> <div class="docstring"><p>Yields the elements `start, start + 1<em>step, start + 2</em>step, etc</p> <pre><code>(<a href="http://l1sp.org/cl/count" class="xref">count</a> 2 4)
;; 2, 6, 10, 14, etc</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:IMAP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AIMAP">IMAP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PRED</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERLIKES</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#304:0">Source</a>  </header> <div class="docstring"><p>Applies <code>fn</code> to the first elements of each iterable in <code>iterlikes</code>, then to the seconds, etc</p> <pre><code>(<a href="#FUNCTION%20PICL%3AIMAP" class="xref">imap</a> <a href="http://l1sp.org/cl/%2B" class="xref">#'+</a> '(1 2) '(3 4))
;; 4, 6</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ISLICE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AISLICE">ISLICE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>    <li class="argument">START</li>    <li class="argument">STOP</li>    <li class="argument">DELTA</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#333:0">Source</a>  </header> <div class="docstring"><p>Works like Python's <a href="https://docs.python.org/3.8/library/itertools.html#itertools.islice">islice</a></p> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ITER-TO-LIST"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AITER-TO-LIST">ITER-TO-LIST</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/utils.lisp#4:0">Source</a>  </header> <div class="docstring"><p>Reads <code>iterlike</code> into a list</p> <pre><code>(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 4))
;; (0 1 2 3)
(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="http://l1sp.org/cl/count" class="xref">count</a>))
;; Out of memory error!</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ITER-TO-VEC"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AITER-TO-VEC">ITER-TO-VEC</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/utils.lisp#20:0">Source</a>  </header> <div class="docstring"><p>Reads <code>iterlike</code> into a vector</p> <pre><code>(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 4))
;; #(0 1 2 3)
(<a href="#FUNCTION%20PICL%3AITER-TO-LIST" class="xref">iter-to-list</a> (<a href="http://l1sp.org/cl/count" class="xref">count</a>))
;; Out of memory error!</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:NEXT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ANEXT">NEXT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERATOR</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/interface.lisp#11:0">Source</a>  </header> <div class="docstring"><p>Produces two values, the payload and the alive-indicator</p> <p>While iterator is not yet exhausted, calling next will yield its next item and a
  truthy alive-indicator</p> <p>After iterator has been exhausted all further calls should yield an alive-indicator
  of nil, and the payload should be ignored by the callee</p> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:PERMUTATIONS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3APERMUTATIONS">PERMUTATIONS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">R</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/combinatoric.lisp#58:0">Source</a>  </header> <div class="docstring"><p><code>r</code>-permutations of input iterable, returned as vectors in lexicographic order.</p> <p>If <code>r</code> is not given, it defaults to the length of the input iterable</p> <pre><code>(<a href="#FUNCTION%20PICL%3APERMUTATIONS" class="xref">permutations</a> '(1 2 3))
;; #(1 2 3), #(1 3 2), #(2 1 3), #(2 3 1), #(3 1 2), #(3 2 1)
(<a href="#FUNCTION%20PICL%3APERMUTATIONS" class="xref">permutations</a> '(1 2 3) 2)
;; #(1 2), #(1 3), #(2 1), #(2 3), #(3 1), #(3 2)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:PRODUCT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3APRODUCT">PRODUCT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERLIKES</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/combinatoric.lisp#8:0">Source</a>  </header> <div class="docstring"><p>Cartesian product of input iterables, returned as vectors in lexicographic order.</p> <p>When given a single iterable and a <code><a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a></code> argument of <code>n</code>, equivalent to computing the
product of <code>n</code> copies of its argument</p> <pre><code>(<a href="#FUNCTION%20PICL%3APRODUCT" class="xref">product</a> '(1 2) '(3 4))
;; #(1 3), #(1 4), #(2 3), #(2 4)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:RANGE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ARANGE">RANGE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">S0</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">S1</li>    <li class="argument">STEP</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#17:0">Source</a>  </header> <div class="docstring"><pre><code>(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 5)
;; 0, 1, 2, 3, 4
(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 2 5)
;; 2, 3, 4
(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> -2)
;; 0, -1
(<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 1 7 2)
;; 1, 3, 5</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:REPEAT"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AREPEAT">REPEAT</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITEM</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">MAX-REPEATS</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#57:0">Source</a>  </header> <div class="docstring"><p>Yields its argument forever or <code>max-repeats</code> times, if given</p> <pre><code>(<a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a> t)
;; t, t, etc
(<a href="#FUNCTION%20PICL%3AREPEAT" class="xref">repeat</a> t 4)
;; t, t, t, t</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:STARMAP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ASTARMAP">STARMAP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FN</li>    <li class="argument">ITERABLE-OF-ITERABLES</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#288:0">Source</a>  </header> <div class="docstring"><p>Applies <code>fn</code> to the first argument of <code>iterable-of-iterables</code>, then the second, etc</p> <pre><code>(<a href="#FUNCTION%20PICL%3ASTARMAP" class="xref">starmap</a> <a href="http://l1sp.org/cl/%2B" class="xref">#'+</a> '(1 2) '(3 4))
;; 3, 7</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:TAKE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ATAKE">TAKE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">N</li>    <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/utils.lisp#41:0">Source</a>  </header> <div class="docstring"><p>Returns a list consisting of the first <code>n</code> (or fewer, if the iterator runs out) items of iterlike</p> <pre><code>(<a href="#FUNCTION%20PICL%3ATAKE" class="xref">take</a> 5 (<a href="http://l1sp.org/cl/count" class="xref">count</a>))
;; (0 1 2 3 4)
take 30 (<a href="#FUNCTION%20PICL%3ARANGE" class="xref">range</a> 4)
;; (0 1 2 3)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:TAKEWHILE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ATAKEWHILE">TAKEWHILE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">PREDICATE</li>    <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#313:0">Source</a>  </header> <div class="docstring"><p>Yields elements of <code>iterlike</code> for which <code>predicate</code> is truthy, terminating once it
first returns nil</p> <pre><code>(<a href="#FUNCTION%20PICL%3ATAKEWHILE" class="xref">takewhile</a> (lambda (x) (<a href="http://l1sp.org/cl/%3C" class="xref">&lt;</a> 3 x) (<a href="http://l1sp.org/cl/count" class="xref">count</a>)))
;; 0, 1, 2</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:TEE"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3ATEE">TEE</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>    <li class="argument lambda-list-keyword">&amp;OPTIONAL</li>    <li class="argument">N</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#378:0">Source</a>  </header> <div class="docstring"><p>Returns a vector of <code>n</code> independent copies of <code>iterliike</code>. <code>iterlike</code> itself should not be used
after it has been passed to <code><a href="#FUNCTION%20PICL%3ATEE" class="xref">tee</a></code>, otherwise its copies will not be properly updated</p> <p>If the base iterable is large be careful not to advance any copy too far ahead of the others, as
elements which have not yet been consumed by all copies do need to be stored in memory.</p> <pre><code>tees <a href="http://l1sp.org/cl/-" class="xref">-</a> (<a href="#FUNCTION%20PICL%3ATEE" class="xref">tee</a> '(1 2 3 4))
;; tees[0] =&gt; 1, 2, 3, 4
;; tees[1] =&gt; 1, 2, 3, 4</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ZIP"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AZIP">ZIP</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERLIKES</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#161:0">Source</a>  </header> <div class="docstring"><p>Returns vectors consisting of the first elements from each iterable in <code>iterlike</code>, then the
second, etc until one is consumed</p> <pre><code>(<a href="#FUNCTION%20PICL%3AZIP" class="xref">zip</a> '(1 2 3) '(a b c d))
;; #(1 a). #(2 b), #(3 c)</code></pre> </div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION PICL:ZIP-LONGEST"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20PICL%3AZIP-LONGEST">ZIP-LONGEST</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">FILL-ITEM</li>    <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">ITERLIKES</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/itertools.lisp#200:0">Source</a>  </header> <div class="docstring"><p>Returns vectors consisting of the first elements from each iterable in <code>iterlike</code>, then the
second, etc until <em>all</em> are consumed. Once a constituent iterable has been exhausted, <code>fill-value</code> is used to pad the vector in its place.</p> <pre><code>(<a href="#FUNCTION%20PICL%3AZIP" class="xref">zip</a> nil '(1 2 3) '(a b c d))
;; #(1 a). #(2 b), #(3 c), #(nil d)</code></pre> </div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION PICL:MAKE-ITERATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20PICL%3AMAKE-ITERATOR">MAKE-ITERATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ITERLIKE</li>  </ul>  <a class="source-link" href="file:///home/anlsh/Code/picl/src/interface.lisp#3:0">Source</a>  </header> <div class="docstring"><p>Creates an iterator from <code>iterlike</code>: an iterator is simply anything which can be passed
   as an argument to <code><a href="#FUNCTION%20PICL%3ANEXT" class="xref">next</a></code></p> </div> </article> </li> </ul> </article> </li> </ul> </section>  </article> <script>window.addEventListener("DOMContentLoaded", function(){
    var unmarkElement = function(el){
        if(el.tagName === "mark" || el.tagName === "MARK"){
            [].forEach.call(el.childNodes, function(child){
                el.parentNode.insertBefore(child, el);
            });
            el.parentNode.removeChild(el);
        }else if(el.parentNode.tagName === "mark"){
            return unmarkElement(el.parentNode);
        }
        return null;
    }

    var unmarkAll = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("mark"), unmarkElement);
    }
    
    var markElement = function(el){
        if(el.parentNode.tagName === "mark" || el.parentNode.tagName === "MARK"){
            return el.parentNode;
        } else {
            unmarkAll();
            var marked = document.createElement("mark");
            el.parentNode.insertBefore(marked, el);
            marked.appendChild(el);
            return marked;
        }
    }

    var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html>   var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html> 